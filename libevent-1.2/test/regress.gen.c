/*
 * Automatically generated from regress.rpc
 * by event_rpcgen.py/0.1.  DO NOT EDIT THIS FILE.
 */

#include <sys/types.h>
#include <sys/time.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <event.h>


#include "regress.gen.h"

void event_err(int eval, const char *fmt, ...);
void event_warn(const char *fmt, ...);
void event_errx(int eval, const char *fmt, ...);
void event_warnx(const char *fmt, ...);


/*
 * Implementation of msg
 */

struct msg *
msg_new()
{
  struct msg *tmp;
  if ((tmp = malloc(sizeof(struct msg))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->from_name_data = NULL;
  tmp->from_name_assign = msg_from_name_assign;
  tmp->from_name_get = msg_from_name_get;
  tmp->from_name_set = 0;

  tmp->to_name_data = NULL;
  tmp->to_name_assign = msg_to_name_assign;
  tmp->to_name_get = msg_to_name_get;
  tmp->to_name_set = 0;

  tmp->kill_data = NULL;
  tmp->kill_assign = msg_kill_assign;
  tmp->kill_get = msg_kill_get;
  tmp->kill_set = 0;

  tmp->run_data = NULL;
  tmp->run_length = 0;
  tmp->run_assign = msg_run_assign;
  tmp->run_get = msg_run_get;
  tmp->run_add = msg_run_add;
  tmp->run_set = 0;

  return (tmp);
}




struct run *
msg_run_add(struct msg *msg)
{
  msg->run_length++;
  msg->run_data = (struct run**)realloc(msg->run_data,   msg->run_length * sizeof(struct run*));
  if (msg->run_data == NULL)
    return (NULL);
  msg->run_data[msg->run_length - 1] = run_new();
  if (msg->run_data[msg->run_length - 1] == NULL) {
    msg->run_length--; 
    return (NULL);
  }
  msg->run_set = 1;
  return (msg->run_data[msg->run_length - 1]);
}

int
msg_from_name_assign(struct msg *msg, const char * value)
{
  if (msg->from_name_data != NULL)
    free(msg->from_name_data);
  if ((msg->from_name_data = strdup(value)) == NULL)
    return (-1);
  msg->from_name_set = 1;
  return (0);
}

int
msg_to_name_assign(struct msg *msg, const char * value)
{
  if (msg->to_name_data != NULL)
    free(msg->to_name_data);
  if ((msg->to_name_data = strdup(value)) == NULL)
    return (-1);
  msg->to_name_set = 1;
  return (0);
}

int
msg_kill_assign(struct msg *msg, const struct kill *value)
{
  struct evbuffer *tmp = NULL;
  if (msg->kill_set) {
    kill_clear(msg->kill_data);
    msg->kill_set = 0;
  } else {
    msg->kill_data = kill_new();
    if (msg->kill_data == NULL) {
      event_warn("%s: kill_new()", __func__);
      goto error;
    }
  }
  if ((tmp = evbuffer_new()) == NULL) {
    event_warn("%s: evbuffer_new()", __func__);
    goto error;
  }
  kill_marshal(tmp, value); 
  if (kill_unmarshal(msg->kill_data, tmp) == -1) {
    event_warnx("%s: kill_unmarshal", __func__);
    goto error;
  }
  msg->kill_set = 1;
  evbuffer_free(tmp);
  return (0);
 error:
  if (tmp != NULL)
    evbuffer_free(tmp);
  if (msg->kill_data != NULL) {
    kill_free(msg->kill_data);
    msg->kill_data = NULL;
  }
  return (-1);
}

int
msg_run_assign(struct msg *msg, int off, const struct run *value)
{
  struct evbuffer *tmp = NULL;
  if (msg->run_set != 1)
    return (-1);
  if (off >= msg->run_length)
    return (-1);

  run_clear(msg->run_data[off]);
  if ((tmp = evbuffer_new()) == NULL) {
    event_warn("%s: evbuffer_new()", __func__);
    goto error;
  }
  run_marshal(tmp, value); 
  if (run_unmarshal(msg->run_data[off], tmp) == -1) {
    event_warnx("%s: run_unmarshal", __func__);
    goto error;
  }
  evbuffer_free(tmp);
  return (0);
 error:
  if (tmp != NULL)
    evbuffer_free(tmp);
  run_clear(msg->run_data[off]);
  return (-1);
}

int
msg_from_name_get(struct msg *msg, char * *value)
{
  if (msg->from_name_set != 1)
    return (-1);
  *value = msg->from_name_data;
  return (0);
}

int
msg_to_name_get(struct msg *msg, char * *value)
{
  if (msg->to_name_set != 1)
    return (-1);
  *value = msg->to_name_data;
  return (0);
}

int
msg_kill_get(struct msg *msg, struct kill **value)
{
  if (msg->kill_set != 1) {
    msg->kill_data = kill_new();
    if (msg->kill_data == NULL)
      return (-1);
    msg->kill_set = 1;
  }
  *value = msg->kill_data;
  return (0);
}

int
msg_run_get(struct msg *msg, int offset, struct run **value)
{
  if (msg->run_set != 1)
    return (-1);
  if (offset >= msg->run_length)
    return (-1);
  *value = msg->run_data[offset];
  return (0);
}

void
msg_clear(struct msg *tmp)
{
  if (tmp->from_name_set == 1) {
    free (tmp->from_name_data);
    tmp->from_name_data = NULL;
    tmp->from_name_set = 0;
  }
  if (tmp->to_name_set == 1) {
    free (tmp->to_name_data);
    tmp->to_name_data = NULL;
    tmp->to_name_set = 0;
  }
  if (tmp->kill_set == 1) {
    kill_free(tmp->kill_data);
    tmp->kill_data = NULL;
    tmp->kill_set = 0;
  }
  if (tmp->run_set == 1) {
    int i;
    for (i = 0; i < tmp->run_length; ++i) {
      run_free(tmp->run_data[i]);
    }
    free(tmp->run_data);
    tmp->run_data = NULL;
    tmp->run_set = 0;
    tmp->run_length = 0;
  }
}

void
msg_free(struct msg *tmp)
{
  if (tmp->from_name_data != NULL)
      free (tmp->from_name_data); 
  if (tmp->to_name_data != NULL)
      free (tmp->to_name_data); 
  if (tmp->kill_data != NULL)
      kill_free(tmp->kill_data); 
  if (tmp->run_data != NULL) {
    int i;
    for (i = 0; i < tmp->run_length; ++i) {
      run_free(tmp->run_data[i]); 
      tmp->run_data[i] = NULL;
    }
    free(tmp->run_data);
    tmp->run_data = NULL;
    tmp->run_length = 0;
  }
  free(tmp);
}

void
msg_marshal(struct evbuffer *evbuf, const struct msg *tmp){
  evtag_marshal_string(evbuf, MSG_FROM_NAME, tmp->from_name_data);
  evtag_marshal_string(evbuf, MSG_TO_NAME, tmp->to_name_data);
  if (tmp->kill_set) {
    evtag_marshal_kill(evbuf, MSG_KILL, tmp->kill_data);
  }
  {
    int i;
    for (i = 0; i < tmp->run_length; ++i) {
      evtag_marshal_run(evbuf, MSG_RUN, tmp->run_data[i]);
    }
  }
}

int
msg_unmarshal(struct msg *tmp,  struct evbuffer *evbuf)
{
  u_int8_t tag;
  while (EVBUFFER_LENGTH(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case MSG_FROM_NAME:

        if (tmp->from_name_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, MSG_FROM_NAME, &tmp->from_name_data) == -1) {
          event_warnx("%s: failed to unmarshal from_name", __func__);
          return (-1);
        }
        tmp->from_name_set = 1;
        break;

      case MSG_TO_NAME:

        if (tmp->to_name_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, MSG_TO_NAME, &tmp->to_name_data) == -1) {
          event_warnx("%s: failed to unmarshal to_name", __func__);
          return (-1);
        }
        tmp->to_name_set = 1;
        break;

      case MSG_KILL:

        if (tmp->kill_set)
          return (-1);
        tmp->kill_data = kill_new();
        if (tmp->kill_data == NULL)
          return (-1);
        if (evtag_unmarshal_kill(evbuf, MSG_KILL, tmp->kill_data) == -1) {
          event_warnx("%s: failed to unmarshal kill", __func__);
          return (-1);
        }
        tmp->kill_set = 1;
        break;

      case MSG_RUN:

        if (msg_run_add(tmp) == NULL)
          return (-1);
        if (evtag_unmarshal_run(evbuf, MSG_RUN, tmp->run_data[tmp->run_length - 1]) == -1) {
          tmp->run_length--; 
          event_warnx("%s: failed to unmarshal run", __func__);
          return (-1);
        }
        tmp->run_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (msg_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
msg_complete(struct msg *msg)
{
  if (!msg->from_name_set)
    return (-1);
  if (!msg->to_name_set)
    return (-1);
  if (msg->kill_set && kill_complete(msg->kill_data) == -1)
    return (-1);
  {
    int i;
    for (i = 0; i < msg->run_length; ++i) {
      if (run_complete(msg->run_data[i]) == -1)
        return (-1);
    }
  }
  return (0);
}

int
evtag_unmarshal_msg(struct evbuffer *evbuf, u_int8_t need_tag,  struct msg *msg)
{
  u_int8_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (msg_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_msg(struct evbuffer *evbuf, u_int8_t tag, const struct msg *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  evbuffer_drain(_buf, -1);
  msg_marshal(_buf, msg);
  evtag_marshal(evbuf, tag, EVBUFFER_DATA(_buf), EVBUFFER_LENGTH(_buf));
  evbuffer_free(_buf);
}

/*
 * Implementation of kill
 */

struct kill *
kill_new()
{
  struct kill *tmp;
  if ((tmp = malloc(sizeof(struct kill))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->weapon_data = NULL;
  tmp->weapon_assign = kill_weapon_assign;
  tmp->weapon_get = kill_weapon_get;
  tmp->weapon_set = 0;

  tmp->action_data = NULL;
  tmp->action_assign = kill_action_assign;
  tmp->action_get = kill_action_get;
  tmp->action_set = 0;

  return (tmp);
}



int
kill_weapon_assign(struct kill *msg, const char * value)
{
  if (msg->weapon_data != NULL)
    free(msg->weapon_data);
  if ((msg->weapon_data = strdup(value)) == NULL)
    return (-1);
  msg->weapon_set = 1;
  return (0);
}

int
kill_action_assign(struct kill *msg, const char * value)
{
  if (msg->action_data != NULL)
    free(msg->action_data);
  if ((msg->action_data = strdup(value)) == NULL)
    return (-1);
  msg->action_set = 1;
  return (0);
}

int
kill_weapon_get(struct kill *msg, char * *value)
{
  if (msg->weapon_set != 1)
    return (-1);
  *value = msg->weapon_data;
  return (0);
}

int
kill_action_get(struct kill *msg, char * *value)
{
  if (msg->action_set != 1)
    return (-1);
  *value = msg->action_data;
  return (0);
}

void
kill_clear(struct kill *tmp)
{
  if (tmp->weapon_set == 1) {
    free (tmp->weapon_data);
    tmp->weapon_data = NULL;
    tmp->weapon_set = 0;
  }
  if (tmp->action_set == 1) {
    free (tmp->action_data);
    tmp->action_data = NULL;
    tmp->action_set = 0;
  }
}

void
kill_free(struct kill *tmp)
{
  if (tmp->weapon_data != NULL)
      free (tmp->weapon_data); 
  if (tmp->action_data != NULL)
      free (tmp->action_data); 
  free(tmp);
}

void
kill_marshal(struct evbuffer *evbuf, const struct kill *tmp){
  evtag_marshal_string(evbuf, KILL_WEAPON, tmp->weapon_data);
  evtag_marshal_string(evbuf, KILL_ACTION, tmp->action_data);
}

int
kill_unmarshal(struct kill *tmp,  struct evbuffer *evbuf)
{
  u_int8_t tag;
  while (EVBUFFER_LENGTH(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case KILL_WEAPON:

        if (tmp->weapon_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, KILL_WEAPON, &tmp->weapon_data) == -1) {
          event_warnx("%s: failed to unmarshal weapon", __func__);
          return (-1);
        }
        tmp->weapon_set = 1;
        break;

      case KILL_ACTION:

        if (tmp->action_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, KILL_ACTION, &tmp->action_data) == -1) {
          event_warnx("%s: failed to unmarshal action", __func__);
          return (-1);
        }
        tmp->action_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (kill_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
kill_complete(struct kill *msg)
{
  if (!msg->weapon_set)
    return (-1);
  if (!msg->action_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_kill(struct evbuffer *evbuf, u_int8_t need_tag,  struct kill *msg)
{
  u_int8_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (kill_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_kill(struct evbuffer *evbuf, u_int8_t tag, const struct kill *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  evbuffer_drain(_buf, -1);
  kill_marshal(_buf, msg);
  evtag_marshal(evbuf, tag, EVBUFFER_DATA(_buf), EVBUFFER_LENGTH(_buf));
  evbuffer_free(_buf);
}

/*
 * Implementation of run
 */

struct run *
run_new()
{
  struct run *tmp;
  if ((tmp = malloc(sizeof(struct run))) == NULL) {
    event_warn("%s: malloc", __func__);
    return (NULL);
  }
  tmp->how_data = NULL;
  tmp->how_assign = run_how_assign;
  tmp->how_get = run_how_get;
  tmp->how_set = 0;

  return (tmp);
}


int
run_how_assign(struct run *msg, const char * value)
{
  if (msg->how_data != NULL)
    free(msg->how_data);
  if ((msg->how_data = strdup(value)) == NULL)
    return (-1);
  msg->how_set = 1;
  return (0);
}

int
run_how_get(struct run *msg, char * *value)
{
  if (msg->how_set != 1)
    return (-1);
  *value = msg->how_data;
  return (0);
}

void
run_clear(struct run *tmp)
{
  if (tmp->how_set == 1) {
    free (tmp->how_data);
    tmp->how_data = NULL;
    tmp->how_set = 0;
  }
}

void
run_free(struct run *tmp)
{
  if (tmp->how_data != NULL)
      free (tmp->how_data); 
  free(tmp);
}

void
run_marshal(struct evbuffer *evbuf, const struct run *tmp){
  evtag_marshal_string(evbuf, RUN_HOW, tmp->how_data);
}

int
run_unmarshal(struct run *tmp,  struct evbuffer *evbuf)
{
  u_int8_t tag;
  while (EVBUFFER_LENGTH(evbuf) > 0) {
    if (evtag_peek(evbuf, &tag) == -1)
      return (-1);
    switch (tag) {

      case RUN_HOW:

        if (tmp->how_set)
          return (-1);
        if (evtag_unmarshal_string(evbuf, RUN_HOW, &tmp->how_data) == -1) {
          event_warnx("%s: failed to unmarshal how", __func__);
          return (-1);
        }
        tmp->how_set = 1;
        break;

      default:
        return -1;
    }
  }

  if (run_complete(tmp) == -1)
    return (-1);
  return (0);
}

int
run_complete(struct run *msg)
{
  if (!msg->how_set)
    return (-1);
  return (0);
}

int
evtag_unmarshal_run(struct evbuffer *evbuf, u_int8_t need_tag,  struct run *msg)
{
  u_int8_t tag;
  int res = -1;

  struct evbuffer *tmp = evbuffer_new();

  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
    goto error;

  if (run_unmarshal(msg, tmp) == -1)
    goto error;

  res = 0;

 error:
  evbuffer_free(tmp);
  return (res);
}

void
evtag_marshal_run(struct evbuffer *evbuf, u_int8_t tag, const struct run *msg)
{
  struct evbuffer *_buf = evbuffer_new();
  assert(_buf != NULL);
  evbuffer_drain(_buf, -1);
  run_marshal(_buf, msg);
  evtag_marshal(evbuf, tag, EVBUFFER_DATA(_buf), EVBUFFER_LENGTH(_buf));
  evbuffer_free(_buf);
}

